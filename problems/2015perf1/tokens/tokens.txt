토큰 게임
Time Limit : 1000ms

[이 문제는 C++ 언어로만 채점 가능합니다!]

승원이와 재현이는 N * N 행렬과, 0 ~ N-1까지의 번호가 붙어있는 N개의 토큰을 가지고 있다. 

이제 둘은 토큰을 서로 나눠가지면서 하는 게임인, “토큰 게임”을 진행하려고 한다. 게임의 룰은 다음과 같다.

 * 먼저 승원이가 토큰을 가져가며, 그 후 둘이 번갈아가면서 토큰을 가져간다.
 * 행렬에서 i행 j열의 값은, i번째 토큰과 j번째 토큰을 모두 소유한 자의 것이 된다. 
 * 이런 식으로 게임을 진행하면, 최후에는 승원이의 영역과 재현이의 영역, 그리고 둘 다 아닌 영역이 존재할 것이다. 이긴 자는 |승원이의 영역의 값 합 - 재현이의 영역의 값 합| 만큼의 승점을 올리게 된다.

재현이를 도와서 최적의 전략으로 게임을 진행하자. 여기서 “최적의 전략”이라 함은, 이길 수 있으면 최대의 승점으로, 이길 수 없다면 승원이에게 최소의 승점을 올리게 하는 전략을 뜻한다.

Input
이 문제는 Interactive 문제이다. 당신의 프로그램은 "tokens.h"를 include한 후, 다음과 같은 함수를 구현해야 한다.

void init(int N, int A[40][40]);
 : 초기 행렬의 크기와 행렬의 값이 주어진다. 당신은 이 값을 토대로 전역 변수 등을 초기화할 수 있다.

int play(int X);
 : 이 함수는, 승원이가 X (0 <= X < N) 번 토큰을 집어갔음을 의미하는 함수이다. 토큰을 집지 못하거나, 집지 않으려 할 경우 -1을, 아닐 경우 재현이가 집어갈 토큰의 번호를 반환하면 된다. 정의되지 않거나 이미 집어가진 토큰 번호를 반환할 경우 오답 판정되니 주의하라.

또한, 제출되는 프로그램이 표준 / 파일 입출력을 시도하려 할 경우 역시 오답 판정된다.

프로그램의 작동을 테스트 할 수 있는 sample grader를 사용할 수 있다. (다운로드 : )

1 <= N <= 40이며, A에 들어있는 값은 0 이상이다.

[Sub-Task Info]
1/3의 테스트 케이스는 N <= 10을 만족한다.

Output
없음.

Sample Input
입력1
N = 3, A = {{2,8,1},{3,5,5},{3,2,7}}, play(1) -> 2, play(0) -> -1

출력1
-12